/**
 * @file Adc.c
 * @author Seb Madgwick
 * @brief ADC driver.
 */

//------------------------------------------------------------------------------
// Includes

#include "Adc.h"
#include "definitions.h"
#include <stdint.h>

//------------------------------------------------------------------------------
// Definitions

/**
 * @brief Oversampling factor.  A oversampling factor of 64 is equivalent to an
 * extra 3 bits of resolution.
 */
#define OVERSAMPLING 64

/**
 * @brief Scaling for 12-bit resolution and 3.0 V reference.
 */
#define SCALING (3.0f / ((float) OVERSAMPLING * 4095.0f))

/**
 * @brief Accumulator.
 */
typedef struct {
    uint32_t numberOfSamples;
    uint32_t ch1;
    uint32_t ch2;
    uint32_t ch3;
    uint32_t ch4;
    uint32_t ch5;
    uint32_t ch6;
    uint32_t ch7;
    uint32_t ch8;
} Accumulator;

//------------------------------------------------------------------------------
// Variables

static Accumulator accumulator;
static AdcData data;

//------------------------------------------------------------------------------
// Functions

/**
 * @brief Initialises module.  This function should be called once, on system
 * start up.
 */
void AdcInitialise(void) {

    // Configure ADC
    AD1CON1bits.SSRC = 0b0111; // Internal counter ends sampling and starts conversion (auto-convert)
    AD1CON1bits.MODE12 = 1; // 12-bit ADC operation
    AD1CON1bits.ASAM = 1; // Sampling begins immediately after last conversion completes; SAMP bit is automatically set
    AD1CON2bits.CSCNA = 1; // Scan inputs
    AD1CON2bits.SMPI = 7; // Interrupts at the completion of conversion for each 8th sample/convert sequence
    AD1CON3bits.SAMC = 24;
    AD1CON3bits.ADCS = 6;
    AD1CSS = (1 << 0) | (1 << 1) | (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 10); // select inputs for scan

    // Enable interrupt
    EVIC_SourceEnable(INT_SOURCE_ADC);

    // Start ADC
    AD1CON1bits.ON = 1;
}

/**
 * @brief ADC interrupt handler.  This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void AdcInterrupt(void) {
    accumulator.numberOfSamples++;
    accumulator.ch1 += ADC1BUF7;
    accumulator.ch2 += ADC1BUF6;
    accumulator.ch3 += ADC1BUF5;
    accumulator.ch4 += ADC1BUF0;
    accumulator.ch5 += ADC1BUF1;
    accumulator.ch6 += ADC1BUF3;
    accumulator.ch7 += ADC1BUF4;
    accumulator.ch8 += ADC1BUF2;
    if (accumulator.numberOfSamples >= OVERSAMPLING) {
        data.counter++;
        data.ch1 = accumulator.ch1 * SCALING;
        data.ch2 = accumulator.ch2 * SCALING;
        data.ch3 = accumulator.ch3 * SCALING;
        data.ch4 = accumulator.ch4 * SCALING;
        data.ch5 = accumulator.ch5 * SCALING;
        data.ch6 = accumulator.ch6 * SCALING;
        data.ch7 = accumulator.ch7 * SCALING;
        data.ch8 = accumulator.ch8 * SCALING;
        static const Accumulator zeros;
        accumulator = zeros;
    }
    EVIC_SourceStatusClear(INT_SOURCE_ADC);
}

/**
 * @brief Gets data.
 * @param data_ Data.
 */
void AdcGetData(AdcData * const data_) {
    do {
        *data_ = data;
    } while (data_->counter != data.counter);
}

//------------------------------------------------------------------------------
// End of file
